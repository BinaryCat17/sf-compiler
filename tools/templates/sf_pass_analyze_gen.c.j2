#include <sionflow/compiler/sf_compiler.h>
#include "../../compiler/src/sf_passes.h"
#include "../../compiler/src/sf_compiler_internal.h"
#include <sionflow/base/sf_log.h>
#include <sionflow/base/sf_shape.h>
#include <sionflow/isa/sf_opcodes.h>
#include <string.h>

/**
 * SionFlow Compiler Shape Resolvers
 * Automatically generated from isa.json. DO NOT EDIT.
 */

typedef bool (*sf_shape_resolver)(sf_ir_node* node, sf_ir_node* inputs[4], sf_compiler_diag* diag);

{% for rule in constants.shape_rules %}
{% if rule.logic %}
static bool resolve_{{ rule.id }}(sf_ir_node* node, sf_ir_node* inputs[4], sf_compiler_diag* diag) {
    (void)diag;
    {% if rule.logic.builtin == "broadcast" %}
    if (!inputs[0] || !inputs[1]) return false;
    if (inputs[2]) {
        sf_type_info tmp;
        if (!sf_shape_broadcast(&inputs[0]->out_info, &inputs[1]->out_info, &tmp)) return false;
        return sf_shape_broadcast(&tmp, &inputs[2]->out_info, &node->out_info);
    }
    return sf_shape_broadcast(&inputs[0]->out_info, &inputs[1]->out_info, &node->out_info);
    
    {% elif rule.logic.last_dim_sum %}
    if (!inputs[0] || !inputs[1]) return false;
    node->out_info.ndim = (uint8_t)({{ rule.logic.ndim | replace("p0", "inputs[0]->out_info") }});
    memcpy(node->out_info.shape, inputs[0]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
    int32_t total = 0;
    for (int k = 0; k < 4; ++k) {
        if (!inputs[k]) continue;
        total += (inputs[k]->out_info.ndim == 0) ? 1 : inputs[k]->out_info.shape[inputs[k]->out_info.ndim - 1];
    }
    node->out_info.shape[node->out_info.ndim - 1] = total;
    return true;

    {% elif rule.logic.is_reshape %}
    if (!inputs[1] || inputs[1]->type != SF_NODE_CONST) {
        node->out_info.ndim = inputs[0]->out_info.ndim;
        memcpy(node->out_info.shape, inputs[0]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
    } else {
        node->out_info.ndim = (uint8_t)inputs[1]->const_info.shape[0];
        for (int k = 0; k < node->out_info.ndim; ++k) {
            if (inputs[1]->const_info.dtype == SF_DTYPE_F32) node->out_info.shape[k] = (int32_t)((f32*)inputs[1]->const_data)[k];
            else node->out_info.shape[k] = ((i32*)inputs[1]->const_data)[k];
        }
    }
    return true;

    {% elif rule.logic.is_slice %}
    if (!inputs[0]) return false;
    node->out_info.ndim = inputs[0]->out_info.ndim;
    memcpy(node->out_info.shape, inputs[0]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
    return true;

    {% else %}
        {% if rule.logic.ndim is defined %}
            {% if rule.logic.ndim is string %}
            if (inputs[0]) {
                node->out_info.ndim = (uint8_t)({{ rule.logic.ndim | replace("p0", "inputs[0]->out_info") | replace("p1", "inputs[1]->out_info") | replace("p2", "inputs[2]->out_info") | replace("p3", "inputs[3]->out_info") }});
            }
            {% else %}
            node->out_info.ndim = (uint8_t)({{ rule.logic.ndim }});
            {% endif %}
        {% endif %}
        
        {% if rule.logic.shape %}
            {% if rule.logic.shape == "p0.shape" %}
            if (inputs[0]) {
                memcpy(node->out_info.shape, inputs[0]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
            }
            {% elif rule.logic.shape == "p1.shape" %}
            if (inputs[1]) {
                memcpy(node->out_info.shape, inputs[1]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
            }
            {% elif rule.logic.shape == "reverse(p0.shape)" %}
            if (inputs[0]) {
                for (int k = 0; k < node->out_info.ndim; ++k) {
                    node->out_info.shape[k] = inputs[0]->out_info.shape[node->out_info.ndim - 1 - k];
                }
            }
            {% elif rule.logic.shape == "p0.shape[0:-1]" %}
            if (inputs[0]) {
                for (int k = 0; k < node->out_info.ndim; ++k) {
                    node->out_info.shape[k] = inputs[0]->out_info.shape[k];
                }
            }
            {% elif rule.logic.shape is iterable %}
            if (inputs[0]) {
                {% for dim_expr in rule.logic.shape %}
                {% if dim_expr == "p0.const_val" %}
                {
                    f32 val = 0;
                    if (inputs[0]->type == SF_NODE_CONST && inputs[0]->const_data) {
                        if (inputs[0]->const_info.dtype == SF_DTYPE_F32) val = *(f32*)inputs[0]->const_data;
                        else if (inputs[0]->const_info.dtype == SF_DTYPE_I32) val = (f32)*(i32*)inputs[0]->const_data;
                    }
                    node->out_info.shape[{{ loop.index0 }}] = (int32_t)val;
                }
                {% else %}
                node->out_info.shape[{{ loop.index0 }}] = (int32_t)({{ dim_expr|replace("p0", "inputs[0]->out_info")|replace("p1", "inputs[1]->out_info")|replace("p2", "inputs[2]->out_info")|replace("p3", "inputs[3]->out_info") }});
                {% endif %}
                {% endfor %}
            }
            {% endif %}
        {% endif %}
        return true;
    {% endif %}
}
{% endif %}
{% endfor %}

const sf_shape_resolver SF_GENERATED_SHAPE_RESOLVERS[] = {
    [SF_NODE_UNKNOWN] = NULL,
{% for node in nodes %}
    {% set opcode_meta = meta_by_opcode.get(node.opcode) %}
    {% set rule_id = opcode_meta.shape_rule if opcode_meta else 'special' %}
    {% set rule = None %}
    {% for r in constants.shape_rules %}{% if r.id == rule_id %}{% set rule = r %}{% endif %}{% endfor %}
    [SF_NODE_{{ node.id }}] = {% if rule and rule.logic %}resolve_{{ rule.id }}{% else %}NULL{% endif %}{%- if not loop.last %}, {% endif %}
{%- endfor %}
};
