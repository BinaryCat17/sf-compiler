#include <sionflow/compiler/sf_compiler.h>
#include "../../compiler/src/sf_passes.h"
#include "../../compiler/src/sf_compiler_internal.h"
#include <sionflow/base/sf_log.h>
#include <sionflow/base/sf_shape.h>
#include <sionflow/isa/sf_opcodes.h>
#include <string.h>

/**
 * SionFlow Compiler Shape Resolvers
 * Automatically generated from isa.json. DO NOT EDIT.
 */

typedef bool (*sf_shape_resolver)(sf_ir_node* node, sf_ir_node* inputs[4], sf_compiler_diag* diag);

{% for rule in constants.shape_rules %}
{% if rule.logic %}
static bool resolve_{{ rule.id }}(sf_ir_node* node, sf_ir_node* inputs[4], sf_compiler_diag* diag) {
    (void)diag;
    {% if rule.logic.builtin %}
    // Handled by manual resolver for now: {{ rule.logic.builtin }}
    return false; 
    {% else %}
    {% if rule.logic.ndim is defined %}
    {% if rule.logic.ndim is string %}
    if (inputs[0]) {
        node->out_info.ndim = (uint8_t)({{ rule.logic.ndim | replace("p0", "inputs[0]->out_info") | replace("p1", "inputs[1]->out_info") | replace("p2", "inputs[2]->out_info") | replace("p3", "inputs[3]->out_info") }});
    }
    {% else %}
    node->out_info.ndim = (uint8_t)({{ rule.logic.ndim }});
    {% endif %}
    {% endif %}
    
    {% if rule.logic.shape %}
    {% if rule.logic.shape == "p0.shape" %}
    if (inputs[0]) {
        memcpy(node->out_info.shape, inputs[0]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
    }
    {% elif rule.logic.shape == "p1.shape" %}
    if (inputs[1]) {
        memcpy(node->out_info.shape, inputs[1]->out_info.shape, sizeof(int32_t) * SF_MAX_DIMS);
    }
    {% elif rule.logic.shape == "reverse(p0.shape)" %}
    if (inputs[0]) {
        for (int k = 0; k < node->out_info.ndim; ++k) {
            node->out_info.shape[k] = inputs[0]->out_info.shape[node->out_info.ndim - 1 - k];
        }
    }
    {% elif rule.logic.shape == "p0.shape[0:-1]" %}
    if (inputs[0]) {
        for (int k = 0; k < node->out_info.ndim; ++k) {
            node->out_info.shape[k] = inputs[0]->out_info.shape[k];
        }
    }
    {% elif rule.logic.shape is iterable %}
    if (inputs[0]) {
        {% for dim_expr in rule.logic.shape %}
        {% if dim_expr == "p0.const_val" %}
        {
            f32 val = 0;
            if (inputs[0]->type == SF_NODE_CONST && inputs[0]->const_data) {
                if (inputs[0]->const_info.dtype == SF_DTYPE_F32) val = *(f32*)inputs[0]->const_data;
                else if (inputs[0]->const_info.dtype == SF_DTYPE_I32) val = (f32)*(i32*)inputs[0]->const_data;
            }
            node->out_info.shape[{{ loop.index0 }}] = (int32_t)val;
        }
        {% else %}
        node->out_info.shape[{{ loop.index0 }}] = (int32_t)({{ dim_expr|replace("p0", "inputs[0]->out_info")|replace("p1", "inputs[1]->out_info")|replace("p2", "inputs[2]->out_info")|replace("p3", "inputs[3]->out_info") }});
        {% endif %}
        {% endfor %}
    }
    {% endif %}
    {% endif %}
    return true;
    {% endif %}
}
{% endif %}
{% endfor %}

const sf_shape_resolver SF_GENERATED_SHAPE_RESOLVERS[] = {
{% for rule in constants.shape_rules %}
    {% if rule.logic and not rule.logic.builtin %}resolve_{{ rule.id }}{% else %}NULL{% endif %}{%- if not loop.last %}, {% endif %}
{%- endfor %}
};