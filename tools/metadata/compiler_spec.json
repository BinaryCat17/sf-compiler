{
  "compiler": {
    "name": "SionFlow Compiler",
    "version": "1.0.0"
  },
  "pipeline": [
    { "id": "inline",    "name": "Inlining",        "func": "sf_pass_inline_wrapper" },
    { "id": "decompose", "name": "Decomposition", "func": "sf_pass_decompose" },
    { "id": "simplify",  "name": "Simplification", "func": "sf_pass_simplify" },
    { "id": "fuse",      "name": "Op Fusion",     "func": "sf_pass_fuse" },
    { "id": "sort",      "name": "Topological Sort", "func": "sf_pass_sort" },
    { "id": "analyze_pre", "name": "Pre-Analysis",   "func": "sf_pass_analyze" },
    { "id": "domain",    "name": "Domain Splitting", "func": "sf_pass_domain_split" },
    { "id": "analyze",   "name": "Static Analysis",  "func": "sf_pass_analyze" },
    { "id": "validate",  "name": "Validation",    "func": "sf_pass_validate" },
    { "id": "liveness",  "name": "Liveness Analysis", "func": "sf_pass_liveness" },
    { "id": "task_plan", "name": "Task Planning", "func": "sf_pass_task_plan" }
  ],
  "aliases": [
    { "from": "Index", "to": "INDEX_X", "reason": "Default index axis" },
    { "from": "Range", "to": "RANGE", "reason": "Sequental generator" },
    { "from": "Sum",   "to": "REDUCE_SUM", "reason": "Short name for reduction" },
    { "from": "Mean",  "to": "MEAN", "reason": "Short name for reduction" },
    { "from": "Square", "to": "SQUARE", "reason": "Math alias" }
  ],
  "fusion_rules": [
    {
      "id": "FUSE_MUL_ADD_TO_FMA",
      "summary": "Fuse (A * B) + C into FMA(A, B, C)",
      "target": "ADD",
      "patterns": [
        {
          "input": "a",
          "match": { "type": "MUL", "use_count": 1 },
          "map_ports": { "a": "a", "b": "b" },
          "other_is_port": "c"
        },
        {
          "input": "b",
          "match": { "type": "MUL", "use_count": 1 },
          "map_ports": { "a": "a", "b": "b" },
          "other_is_port": "c"
        }
      ],
      "replace_with": "FMA"
    }
  ],
  "lowering_rules": [
    {
      "id": "DECOMPOSE_SQUARE",
      "target": "SQUARE",
      "replace_with_subgraph": [
        { "id": "mul", "type": "MUL", "inputs": { "a": "in", "b": "in" } }
      ],
      "output": "mul"
    },
    {
      "id": "DECOMPOSE_MEAN",
      "target": "MEAN",
      "replace_with_subgraph": [
        { "id": "sum", "type": "REDUCE_SUM", "inputs": { "in": "in" } },
        { "id": "size", "type": "SIZE", "inputs": { "in": "in" } },
        { "id": "div", "type": "DIV", "inputs": { "a": "sum", "b": "size" } }
      ],
      "output": "div"
    },
    {
      "id": "DECOMPOSE_MEAN_STABLE",
      "target": "MEAN_STABLE",
      "replace_with_subgraph": [
        { "id": "sum", "type": "REDUCE_SUM_STABLE", "inputs": { "in": "in" } },
        { "id": "size", "type": "SIZE", "inputs": { "in": "in" } },
        { "id": "div", "type": "DIV", "inputs": { "a": "sum", "b": "size" } }
      ],
      "output": "div"
    }
  ],
  "node_constraints": {
    "MATMUL": { 
      "min_rank": 2,
      "assertions": [
        { "type": "MATCH_DIM", "p0": 0, "a0": 1, "p1": 1, "a1": 0, "msg": "Inner dimensions mismatch" }
      ]
    },
    "DOT": { 
      "min_rank": 1, 
      "flags": ["REDUCER"],
      "assertions": [
        { "type": "MATCH_DIM", "p0": 0, "a0": -1, "p1": 1, "a1": -1, "msg": "Last dimensions mismatch" }
      ]
    },
    "ADD": { "flags": ["COMMUTATIVE", "ASSOCIATIVE"], "assertions": [{ "type": "BROADCAST_COMPATIBLE" }] },
    "MUL": { "flags": ["COMMUTATIVE", "ASSOCIATIVE"], "assertions": [{ "type": "BROADCAST_COMPATIBLE" }] },
    "LENGTH": { "min_rank": 1, "flags": ["REDUCER"] },
    "NORMALIZE": { "min_rank": 1 },
    "INDEX_X": { "flags": ["GENERATOR", "SPATIAL"] },
    "INDEX_Y": { "flags": ["GENERATOR", "SPATIAL"] },
    "INDEX_Z": { "flags": ["GENERATOR", "SPATIAL"] },
    "REDUCE_SUM": { "flags": ["REDUCER"] },
    "REDUCE_SUM_STABLE": { "flags": ["REDUCER"] },
    "SIZE": { "flags": ["REDUCER"] },
    "GATHER": { "flags": ["MEMORY"] },
    "SLICE": { "flags": ["MEMORY"] },
    "RESHAPE": { "flags": ["MEMORY"] }
  }
}
